

<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
<title>Your Customized Coding Standard</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
</head>
<body>

<h1>C++ Coding Standard for LAVAflow</h1>
<h3>Entity Naming</h3>
<ul>
<li><a href="#nvcase">
Variables shall begin with a lower case letter.</a>
<li><a href="#nconstcase">
Constants shall be upper case.</a>
<li><a href="#nfuncase">
Functions shall begin with a lower case letter.</a>
<li><a href="#ntypecase">
Types shall begin with an upper case letter.</a>
<li><a href="#ntdefcase">
Typedefs shall begin with a lower case letter.</a>
<li><a href="#netorcase">
Enumerators shall be upper case.</a>
<li><a href="#nmacrocase">
Macros shall be upper case.</a>
</ul>
<h3>Names</h3>
<ul>
<li><a href="#NameSensible">
Use sensible, descriptive names.</a>
<li><a href="#NameEnglish">
Only use english names.</a>
<li><a href="#NameLength">
Variables with a large scope shall have long names, variables with a small scope can have short names.</a>
<li><a href="#UseNamespace">
Use namespaces for identifiers declared in different
modules</a>
</ul>
<h3>Indentation and Spacing</h3>
<ul>
<li><a href="#BracesExdented">
Braces shall follow "Exdented Style".</a>
<li><a href="#IndentLevel">
Braces shall be indented 4 columns to the right of the starting position of the enclosing statement or declaration.</a>
<li><a href="#BracesLoop">
Loop and conditional statements shall always have brace enclosed
sub-statements.</a>
<li><a href="#BracesEmpty">
Braces without any contents may be placed on the same line.</a>
<li><a href="#StmtPerLine">
Each statement shall be placed on a line on its own.</a>
<li><a href="#ObjectPerDecl">
Declare each variable in a separate declaration.</a>
<li><a href="#OperSpace">
All binary arithmetic, bitwise and assignment operators and the ternary
conditional operator (?:) shall be surrounded by spaces; the comma operator
shall be followed by a space but not preceded; all other operators shall
not be used with spaces.</a>
<li><a href="#TabsAvoid">
Do not use tabs.</a>
</ul>
<h3>Comments</h3>
<ul>
<li><a href="#CommentEnglish">
Comments shall be written in english</a>
<li><a href="#CommentC">
Comments shall use the C-style.</a>
<li><a href="#CommentCpp">
Comments shall use the C++-style.</a>
<li><a href="#CommentMultiLine">
Multiple line comments shall be split in one comment per line,
each having the /* and */ markers on the same line.</a>
<li><a href="#CommentPlacement">
All comments shall be placed above the line the comment
describes, indented identically.</a>
<li><a href="#CommentIfDef">
Use <code>#ifdef</code> instead of /* ... */ to comment out blocks
of code.</a>
<li><a href="#CommentClass">
Every class shall have a comment that describes its purpose.</a>
<li><a href="#CommentFunction">
Every function shall have a comment that describes its purpose.</a>
</ul>
<h3>Files</h3>
<ul>
<li><a href="#OneVisibleClass">
There shall only be one externally visible class defined in
each header file.</a>
<li><a href="#FileNameCase">
File name shall be treated as case sensitive.</a>
<li><a href="#CppFileExt">
C++ source files shall have extension "<code>.cxx</code>".</a>
<li><a href="#CppHeaderExt">
C++ header files shall have extension "<code>.h</code>".</a>
<li><a href="#HeaderIncludeGuard">
Header files must have include guards.</a>
<li><a href="#IncludeGuardName">
The name of the macro used in the include guard shall have the same name
as the file (excluding the extension) followed by the suffix "_H".</a>
<li><a href="#HeaderSelfContained">
Header files shall be self-contained</a>
<li><a href="#HeaderSystemUser">
System header files shall be included with <> and project
headers with "".</a>
<li><a href="#IncludeFirst">
Put <code>#include</code> directives at the top of files.</a>
<li><a href="#IncludeAbsoluteAvoid">
Do not use absolute directory names in <code>#include</code>
directives.</a>
<li><a href="#IncludeRelativeAvoid">
Do not use relative directory names in <code>#include</code>
directives.</a>
</ul>
<h3>Declarations</h3>
<ul>
<li><a href="#FunctionParameterNames">
Provide names of parameters in function declarations.</a>
<li><a href="#FunctionPointerTypedef">
Use a typedef to define a pointer to a function.</a>
<li><a href="#ExceptionSpecificationAvoid">
Do not use exception specifications.</a>
<li><a href="#UseVirtual">
Declare inherited functions <code>virtual</code>.</a>
<li><a href="#GlobalVarAvoid">
Do not use global variables.</a>
<li><a href="#SingletonAvoid">
Do not use global variables or singleton objects.</a>
<li><a href="#UsingDeclHeaderAvoid">
Do not use global using declarations and using directives in
headers.</a>
<li><a href="#AccessOrder">
The parts of a class definition must be <code>public</code>,
<code>protected</code> and <code>private</code>.</a>
<li><a href="#PrivateData">
Declare class data private.</a>
<li><a href="#StructAsPodOnly">
Only use the keyword <code>struct</code> for C-style structs.</a>
<li><a href="#PreferFunctionsNonMember">
Functions that can be implemented using public
interface of a class shall not be members.</a>
</ul>
<h3>Statements</h3>
<ul>
<li><a href="#GotoRecoveryOnly">
Only use gotos for error recovery.</a>
<li><a href="#SwitchDefault">
All switch statements shall have a default label.</a>
<li><a href="#DoWhileAvoid">
Do not use <code>do-while</code> loops.</a>
</ul>
<h3>Other Typographical Issues</h3>
<ul>
<li><a href="#MagicNumberAvoid">
Do not use literal numbers other than 0 and 1.</a>
<li><a href="#AssertEncourage">
Use plenty of assertions.</a>
<li><a href="#IncrementPrefix">
Use prefix increment/decrement instead of postfix
increment/decrement when the value of the variable is not used.</a>
<li><a href="#ConditionsWithConstantsLeft">
Write conditional expressions like: if ( 6 == errorNum ) ...</a>
<li><a href="#ConditionsExplicitBool">
Do not rely on implicit conversion to bool in conditions.</a>
<li><a href="#NewCastOps">
Use the new cast operators.</a>
</ul>
<hr />
<h2>Entity Naming</h2>

<a name="nvcase" />
<h3>Variables shall begin with a lower case letter.</h3>
<pre><code>
int runCount;
real** blockBndBox;
</pre></code>

<a name="nconstcase" />
<h3>Constants shall be upper case.</h3>
<pre><code>
double PI = 3.14...;
int MAX_SIZE = ...;
</pre></code>

<a name="nfuncase" />
<h3>Functions shall begin with a lower case letter.</h3>
<pre><code>
int addNumbers(...);
void MyClass::doStuff(...);
</pre></code>

<a name="ntypecase" />
<h3>Types shall begin with an upper case letter.</h3>
<pre><code>
class MyClass{...};
struct MyStruct{...};
</pre></code>

<a name="ntdefcase" />
<h3>Typedef letter case shall attempt to match the case of the root type.</h3>
<pre><code>
typedef unsigned long ulong;

class MyClass{...};
typedef MyClass* MyClassPtr;
</pre></code>

<a name="netorcase" />
<h3>Enumerators shall be upper case.</h3>
<pre><code>
enum Color { RED, GREEN, BLUE };
</pre></code>

<a name="nmacrocase" />
<h3>Macros shall be upper case.</h3>
<pre><code>
#define TIMESTWO(x) (2*x)
</pre></code>

<h2>Names</h2>
<a name="NameSensible" />
<h3>Use sensible, descriptive names.</h3>
<pre><code>
double particlePos[MDIM];
integer numParticle;
</pre></code>


Do not use short cryptic names or names based on internal jokes.
It shall be easy to type a name without looking up how it is spelt.
<p>
Exception: Loop variables and variables with a small scope (less
than 20 lines) may have short names to save space if the purpose of
that variable is obvious.

<a name="NameEnglish" />
<h3>Only use english names.</h3>

It is confusing when mixing languages for names.
English is the preferred language because of its spread in the
software market and because most libraries used already use english.

<a name="NameLength" />
<h3>Variables with a large scope shall have long names, variables with a small scope can have short names.</h3>

Scratch variables used for temporary storage or indices are best kept
short.
A programmer reading such variables shall be able to assume that its
value is not used outside a few lines of code.
Common scratch variables for integers are <code>i</code>, <code>j</code>,
<code>k</code>, <code>m</code>, <code>n</code> and for characters <code>c</code> and
<code>d</code>.

<a name="UseNamespace" />
<h3>Use namespaces for identifiers declared in different
modules</h3>

This avoids name clashes.

<h2>Indentation and Spacing</h2>
<a name="BracesExdented" />
<h3>Braces shall follow "Exdented Style".</h3>

The Exdented Bracing Style means that the curly brace pair are lined
up with the surrounding statement. Statements and declarations
between the braces are indented relative to the braces.

<a name="IndentLevel" />
<h3>Braces shall be indented 4 columns to the right of the starting position of the enclosing statement or declaration.</h3>

Example:
<pre><code>
void f(int a)
{
    int i;
    if (a &gt; 0)
    {
        i = a;
    }
    else
    {
        i = a;
    }
}
</code></pre>

<pre><code>
class A
{
};
</pre></code>


<a name="BracesLoop" />
<h3>Loop and conditional statements shall always have brace enclosed
sub-statements.</h3>

The code looks more consistent if all conditional and loop statements
have braces.
<p>
Even if there is only a single statement after the condition or loop
statement today, there might be a need for more code in the future.

<a name="BracesEmpty" />
<h3>Braces without any contents may be placed on the same line.</h3>

The only time when two braces can occur on the same line is when they do not
contain any code.
<pre><code>
while (...)
{}
</pre></code>

<a name="StmtPerLine" />
<h3>Each statement shall be placed on a line on its own.</h3>

There is no need to make code compact.
Putting several statements on the same line only makes the code
cryptic to read.

<a name="ObjectPerDecl" />
<h3>Declare each variable in a separate declaration.</h3>

This makes it easier to see all variables.

It also avoids the problem of knowing which variables are pointers.
<pre><code>
int* p, i;
</pre></code>
It is easy to forget that the star belongs to the declared name, not the type,
and look at this and say that the type is "pointer to int" and both
<code>p</code> and <code>i</code> are declared to this type.


<a name="OperSpace" />
<h3>All binary arithmetic, bitwise and assignment operators and the ternary
conditional operator (?:) shall be surrounded by spaces; the comma operator
shall be followed by a space but not preceded; all other operators shall
not be used with spaces.</h3>


<a name="TabsAvoid" />
<h3>Do not use tabs.</h3>

Tabs make the source code difficult to read where different programs
treat the tabs differently.
The same code can look very differently in different views.
<p>
Avoid using tabs in your source code to avoid this problem.
Use spaces instead.

<h2>Comments</h2>
<a name="CommentEnglish" />
<h3>Comments shall be written in english</h3>


<a name="CommentC" />
<h3>Comments shall use the C-style.</h3>

Be consistent and use the <code>/* ... */</code> style comments.

<a name="CommentCpp" />
<h3>Comments shall use the C++-style.</h3>

Be consistent and use the <code>// ...</code> style comments.

<a name="CommentMultiLine" />
<h3>Multiple line comments shall be split in one comment per line,
each having the /* and */ markers on the same line.</h3>

Long comments which span several lines are difficult to follow.
Having each line in the comment begin with <code>/*</code> makes the
comment much clearer and easy to identify.
This also avoids problems where comments contain code and possibly
nested comments.

<a name="CommentPlacement" />
<h3>All comments shall be placed above the line the comment
describes, indented identically.</h3>

Being consistent on placement of comments removes any question on what
the comment refers to.

<a name="CommentIfDef" />
<h3>Use <code>#ifdef</code> instead of /* ... */ to comment out blocks
of code.</h3>

The code that is commented out may already contain comments which then
terminate the block comment and causes lots of compile errors or
other harder to find errors.

<a name="CommentClass" />
<h3>Every class shall have a comment that describes its purpose.</h3>


<a name="CommentFunction" />
<h3>Every function shall have a comment that describes its purpose.</h3>


<h2>Files</h2>
<a name="OneVisibleClass" />
<h3>There shall only be one externally visible class defined in
each header file.</h3>

Having as few declarations as possible in a header file reduces header
dependencies.
<p>
The header file shall have the same name as the class plus
extension <code>h</code>.
<p>
External non-member functions that belong to the class interface may
also be declared in the same header file.

<a name="FileNameCase" />
<h3>File name shall be treated as case sensitive.</h3>


<a name="CppFileExt" />
<h3>C++ source files shall have extension "<code>.cxx</code>".</h3>


<a name="CppHeaderExt" />
<h3>C++ header files shall have extension "<code>.h</code>".</h3>


<a name="HeaderIncludeGuard" />
<h3>Header files must have include guards.</h3>

The include guard protects against the header file being included
multiple times.
<p>
Example:
<pre><code>
#ifndef FILE_H
#define FILE_H
...
#endif
</pre></code>

<a name="IncludeGuardName" />
<h3>The name of the macro used in the include guard shall have the same name
as the file (excluding the extension) followed by the suffix "_H".</h3>


<a name="HeaderSelfContained" />
<h3>Header files shall be self-contained</h3>

When a header is included, there shall not be a need to include any
other headers first.
<p>
A simple way to make sure that a header file does not have any dependencies
is to include it first in the corresponding source file.
Example:
<pre><code>
/* foobar.h */

#include "foobar.h"
#include &lt;stdio.h&gt;

...
</pre></code>

<a name="HeaderSystemUser" />
<h3>System header files shall be included with <> and project
headers with "".</h3>


<a name="IncludeFirst" />
<h3>Put <code>#include</code> directives at the top of files.</h3>

Having all <code>#include</code> directives in one place makes it easy to
find them.

<a name="IncludeAbsoluteAvoid" />
<h3>Do not use absolute directory names in <code>#include</code>
directives.</h3>

The directory structure may be different on other systems.

<a name="IncludeRelativeAvoid" />
<h3>Do not use relative directory names in <code>#include</code>
directives.</h3>

The directory structure of the project may change in the future.
It is then difficult to correct all the directory names.

<h2>Declarations</h2>
<a name="FunctionParameterNames" />
<h3>Provide names of parameters in function declarations.</h3>

Parameter names are useful to document what the parameter is used for.
<p>
The parameter names shall be the same in all declarations and
definitions of the function.

<a name="FunctionPointerTypedef" />
<h3>Use a typedef to define a pointer to a function.</h3>

Pointers to functions have a strange syntax.
The code becomes much clearer if you use a typedef for the pointer to
function type.
This typedef name can then be used to declare variables etc.
<pre><code>
double sin(double arg);
typedef double (*trigfunc)(double arg);

/* Usage examples */
trigfunc myFunc = sin;
void callFunc(trigfunc callback);
trigfunc funcTable[10];
</pre></code>

<a name="ExceptionSpecificationAvoid" />
<h3>Do not use exception specifications.</h3>

Exception specifications in C++ are not as useful as they look.
The compiler does not make the code more efficient.
On the contrary, the compiler has to insert code to check that called
functions do not violate the specified exception specification at runtime.

<a name="UseVirtual" />
<h3>Declare inherited functions <code>virtual</code>.</h3>

An inherited function is implicitly <code>virtual</code> if it is declared
<code>virtual</code> in the base class.
Repeat the <code>virtual</code> keyword when declaring an inherited
function in a derived class to make it clear that this function is
<code>virtual</code>.

<a name="GlobalVarAvoid" />
<h3>Do not use global variables.</h3>

Use singleton objects instead.
<p>

Global variables are initialised when the program starts whether it will
be used or not.

A singleton object is only initialised when the object is used the
first time.

<p>
If global variables are using other global variables for their
initialisation there may be a problem if the dependent variables
are not initialised yet.
The initialisation order of global variables in different object files
is not defined.

Singleton objects do not have this problem as the dependent object
will be initialised when it is used.
However, watch out for cyclic dependencies in singleton object initialisations.


<a name="SingletonAvoid" />
<h3>Do not use global variables or singleton objects.</h3>

Global variables and singleton objects break visibility of what
functions do as these can only be used as invisible side effects
of functions.
To make it clear what inputs and outputs a function has, pass these
objects as parameters to the functions.
<p>
If the program will use threads in the future, it may be difficult to
re-write the program to remove the global variables and singleton
objects that cannot be shared between the threads.

<a name="UsingDeclHeaderAvoid" />
<h3>Do not use global using declarations and using directives in
headers.</h3>

Bringing in names from a namespace to the global namespace may cause
conflicts with other headers.
The author of a header does not know in which context the header is
used and should avoid polluting the global namespace.
Instead, only use using declarations in the source files.

<a name="AccessOrder" />
<h3>The parts of a class definition must be <code>public</code>,
<code>protected</code> and <code>private</code>.</h3>

This makes it easy to read the class definition as the <code>public</code>
interface is of interest to most readers.

<a name="PrivateData" />
<h3>Declare class data private.</h3>

Classes shall encapsulate their data and only provide access to this
data by member functions to ensure that data in class objects are
consistent.

<p>
The exception to the rule is C type <code>struct</code> that only contains
data members.


<a name="StructAsPodOnly" />
<h3>Only use the keyword <code>struct</code> for C-style structs.</h3>


<a name="PreferFunctionsNonMember" />
<h3>Functions that can be implemented using public
interface of a class shall not be members.</h3>

A class definition can be kept small and less prone to change if it
only defines the core functionality.
Any other functions that can be implemented with this minimal class
definition shall be implemented as non-member functions.
They are still seen as part of the interface of the class.
<p>
Example:
<pre><code>
class T
{
    T operator+=(const T &amp; right);
};

T operator+(const T &amp; left, const T &amp; right)
{
    T temp(left);
    temp += right;
    return temp;
}
</pre></code>

<h2>Statements</h2>
<a name="GotoRecoveryOnly" />
<h3>Only use gotos for error recovery.</h3>

Although gotos are considered bad and breaks structured coding, it
is sometimes useful for error recovery from deep within nested loops.
In these cases the goto shall only jump to a label below in the code
and only into an outer scope.

<a name="SwitchDefault" />
<h3>All switch statements shall have a default label.</h3>

Even if there is no action for the default label, it shall be included
to show that the programmer has considered values not covered by case
labels.
If the case labels cover all possibilities, it is useful to put an
assertion there to document the fact that it is impossible to get
here.
An assertion also protects from a future situation where a new
possibility is introduced by mistake.

<a name="DoWhileAvoid" />
<h3>Do not use <code>do-while</code> loops.</h3>

<code>do-while</code> loops are less readable than ordinary while loops and for
loops since the conditional is at the bottom of the loop.
The reader must scan the entire loop in order to understand the scope
of the loop.
<p>
In addition, do-while loops are not needed.
Any do-while loop can easily be rewritten into a while loop or a for
loop.
Reducing the number of constructs used enhance readability.

<h2>Other Typographical Issues</h2>
<a name="MagicNumberAvoid" />
<h3>Do not use literal numbers other than 0 and 1.</h3>

Use constants instead of literal numbers to make the code consistent
and easy to maintain.
The name of the constant is also used to document the purpose of the number.

<a name="AssertEncourage" />
<h3>Use plenty of assertions.</h3>

Assertions are useful to verify pre-conditions, post-conditions and
any other conditions that should never happen.
Pre-conditions are useful to verify that functions are called with
valid arguments.
They are also useful as documentation of what argument value ranges a
function is designed to work with.

<p>
Assertions are macros that print error messages when the condition is
not met.
The macros are disabled in release mode and do not cost anything in
performance or used memory in the end product.
<p>
Example: This square root function is only designed to work with
positive numbers.
<pre><code>
#include &lt;assert.h&gt;

double sqrt(double x)
{
    // precondition: x is positive
    assert(x &gt; 0);
    double result;
    ...
    // postcondition: result^2 ~= x
    assert(abs(result*result-x)/x &lt; 1E-8) ;
}
</pre></code>


<a name="IncrementPrefix" />
<h3>Use prefix increment/decrement instead of postfix
increment/decrement when the value of the variable is not used.</h3>

For class objects there may be two different member functions for the
postfix and prefix operations.
The postfix operation has to keep a temporary return value of the object
before changing the object.
For built-in objects this does not matter as the compiler will be able
to optimise away the temporary value when it is not used.
<p>
Even if this only matters for class objects, it is a good habit to use
prefix increment/decrement at all times.


<a name="ConditionsWithConstantsLeft" />
<h3>Write conditional expressions like: <code>if ( 6 == errorNum ) ...</code></h3>

This style avoids accidental assignments of the variable when the
comparison operator is written with only one equal sign (=).

<a name="ConditionsExplicitBool" />
<h3>Do not rely on implicit conversion to bool in conditions.</h3>

<pre><code>
if (ptr)         // wrong
if (ptr != NULL) // ok
</pre></code>

<a name="NewCastOps" />
<h3>Use the new cast operators.</h3>

Use <code>dynamic_cast</code>, <code>const_cast</code>, <code>reinterpret_cast</code>
and <code>static_cast</code> instead of the traditional C cast notation.
These document better what is being performed.

<hr />
<i>Generated 2015-10-02 by <a href="http://www.rosvall.ie/CSG">Coding Standard Generator</a> version 1.13.</i>

</body>
</html>
